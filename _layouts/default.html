<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title>一步一步建立网站</title>
</head>
<body>
<blockquote>
  <a href="http://fulong258.blog.163.com/">【轰隆隆】</a> 的 <a href="http://fulong258.blog.163.com/blog/static/17895044201082951820935">Java自带的线程池ThreadPoolExecutor详细介绍说明和实例应用</a><br>
  <p>来源：YidingHe's Blog</p> 
  <p>从 Java 5 开始，Java 提供了自己的线程池。线程池就是一个线程的容器，每次只执行额定数量的线程。 java.util.concurrent.ThreadPoolExecutor 就是这样的线程池。它很灵活，但使用起来也比较复杂，本文就对其做一个介绍。</p> 
  <p><br></p> 
  <p>首先是构造函数。以最简单的构造函数为例：</p> 
  <p><br>public&nbsp;ThreadPoolExecutor( &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;corePoolSize, &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;maximumPoolSize, &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;keepAliveTime, &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit&nbsp;unit, &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue&nbsp;workQueue)&nbsp;&nbsp;<br>public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) </p> 
  <p>看起来挺复杂的。这里介绍一下。</p> 
  <p><br>corePoolSize 指的是保留的线程池大小。 <br>maximumPoolSize 指的是线程池的最大大小。 <br>keepAliveTime 指的是空闲线程结束的超时时间。 <br>unit 是一个枚举，表示 keepAliveTime 的单位。 <br>workQueue 表示存放任务的队列。<br></p> 
  <p>我们可以从线程池的工作过程中了解这些参数的意义。线程池的工作过程如下：</p> 
  <p><br></p> 
  <p>1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p> 
  <p>2、当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p> 
  <p>&nbsp;&nbsp;&nbsp; a. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p> 
  <p>&nbsp;&nbsp;&nbsp; b. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。</p> 
  <p>&nbsp;&nbsp;&nbsp; c. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；</p> 
  <p>&nbsp;&nbsp;&nbsp; d. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。</p> 
  <p>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</p> 
  <p>4、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p> 
  <p>这样的过程说明，并不是先加入任务就一定会先执行。假设队列大小为 10，corePoolSize 为 3，maximumPoolSize 为 6，那么当加入 20 个任务时，执行的顺序就是这样的：首先执行任务 1、2、3，然后任务 4~13 被放入队列。这时候队列满了，任务 14、15、16 会被马上执行，而任务 17~20 则会抛出异常。最终顺序是：1、2、3、14、15、16、4、5、6、7、8、9、10、11、12、13。下面是一个线程池使用的例子：</p> 
  <p><br>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{ &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue&nbsp;queue&nbsp;=&nbsp;new&nbsp;LinkedBlockingQueue(); &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;ThreadPoolExecutor&nbsp;executor&nbsp;=&nbsp;new&nbsp;ThreadPoolExecutor(3,&nbsp;6,&nbsp;1,&nbsp;TimeUnit.DAYS,&nbsp;queue); &nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;i++)&nbsp;{ &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor.execute(new&nbsp;Runnable()&nbsp;{ &nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{ &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(1000); &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{ &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(String.format("thread&nbsp;%d&nbsp;finished",&nbsp;this.hashCode())); &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;executor.shutdown(); &nbsp;&nbsp;<br>}&nbsp;&nbsp;<br></p> 
  <p>对这个例子的说明如下：<br></p> 
  <p>1、BlockingQueue 只是一个接口，常用的实现类有 LinkedBlockingQueue 和 ArrayBlockingQueue。用 LinkedBlockingQueue 的好处在于没有大小限制。这样的话，因为队列不会满，所以 execute() 不会抛出异常，而线程池中运行的线程数也永远不会超过 corePoolSize 个，keepAliveTime 参数也就没有意义了。</p> 
  <p>2、shutdown() 方法不会阻塞。调用 shutdown() 方法之后，主线程就马上结束了，而线程池会继续运行直到所有任务执行完才会停止。如果不调用 shutdown() 方法，那么线程池会一直保持下去，以便随时添加新的任务。</p> 
  <p>到这里对于这个线程池还只是介绍了一小部分。ThreadPoolExecutor 具有很强的可扩展性，不过扩展它的前提是要熟悉它的工作方式。</p> 
  <p>&nbsp;</p> 
  <p>java.util.concurrent.ThreadPoolExecutor 类提供了丰富的可扩展性。你可以通过创建它的子类来自定义它的行为。例如，我希望当每个任务结束之后打印一条消息，但我又无法修改任务对象，那么我可以这样写：</p> 
  <p> </p>
 </blockquote>
</body>
</html>